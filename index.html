<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>CircuitPython WebBluetooth Test</title>
  </head>
  <body>
    <h1>CircuitPython WebBluetooth Test</h1>
<p>
Make sure you have enabled two flags in <a href="chrome://flags">chrome://flags</a>:
<ul>
<li><a href="chrome://flags/#enable-experimental-web-platform-features">chrome://flags/#enable-experimental-web-platform-features</a></li>
<li><a href="chrome://flags/#enable-web-bluetooth-new-permissions-backend">chrome://flags/#enable-web-bluetooth-new-permissions-backend</a></li>
</ul>

These flags allow the page to reconnect to devices you've already granted them access to.
</p>
<p>
The first step is selecting the device you want to use:
</p>
<p>
One option is to use serial over USB (file transfer over USB isn't currently supported here):
<button id="requestSerialDevice">Request Serial Device</button>
</p>
<p>
Another option is to use serial and file transfer over BLE. CircuitPython boards with <a href="https://circuitpython.org/downloads?features=Bluetooth%2FBTLE">nrf chips need 7.0.0-alpha.4 or newer</a>. The first time a device is connected to your host, you'll need to enable public broadcasting by pressing reset when the faster, blue blink is happening on start up. The device will reset and the second, blue blink will be solid when done successfully.
</p>
<button id="requestBluetoothDevice">Request Bluetooth Device</button>
<p>
If you've done this before and the persistent device API works, then you can click this instead: (If nothing is found, then try the button above even if nothing is found.)
</p>
<button id="connectToBluetoothDevices">Connect to Bluetooth Devices</button>
<p>
Once you are connected, we need to prompt a bond. Without this CircuitPython boards with USB won't continue to advertise after a hard reset or powerloss. This button also loads code.py from the device so click it even if the device has been connected before.
</p>
<button id="promptBond">Bond</button>

<div id="terminal"
     style="position:relative; width:100%; height:200px"></div>

<div id="editor"></div>
<script src='./hterm_all.js'></script>
<script type="module">

import {FileTransferClient} from './_snowpack/pkg/@adafruit/ble-file-transfer.js';
const bleNusServiceUUID  = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const bleNusCharRXUUID   = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
const bleNusCharTXUUID   = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';

var bleDevice;
var serialDevice;
var bleServer;
var serialService;
var rxCharacteristic;
var txCharacteristic;
var client;
var terminal;
var decoder = new TextDecoder();

const BYTES_PER_WRITE = 20;

let connect = document.querySelector('#connectToBluetoothDevices');
let request = document.querySelector('#requestBluetoothDevice');
let bond = document.querySelector('#promptBond');
let request_serial = document.querySelector('#requestSerialDevice');

var connected = false;

async function onConnectToBluetoothDevicesButtonClick() {
  try {
    console.log('Getting existing permitted Bluetooth devices...');
    const devices = await navigator.bluetooth.getDevices();

    console.log('> Got ' + devices.length + ' Bluetooth devices.');
    // These devices may not be powered on or in range, so scan for
    // advertisement packets from them before connecting.
    for (const device of devices) {
      connectToBluetoothDevice(device);
    }
  }
  catch(error) {
    console.log('Argh! ' + error);
  }
}

async function debugLog(msg) {
  terminal.io.print('\x1b[93m');
  terminal.io.print(msg);
  terminal.io.println('\x1b[m');
}

async function onBLESerialReceive(e) {
  // console.log("rcv", e.target.value.buffer);
  terminal.io.print(decoder.decode(e.target.value.buffer, {stream: true}));
}

async function serialTransmit(msg) {
  if (serialDevice && serialDevice.writable) {
    const encoder = new TextEncoder();
    const writer = serialDevice.writable.getWriter();
    await writer.write(encoder.encode(s));
    writer.releaseLock();
  }
  if (rxCharacteristic) {
    let encoder = new TextEncoder();
    let value = encoder.encode(msg);
    try {
        if (value.byteLength < BYTES_PER_WRITE) {
            await rxCharacteristic.writeValueWithoutResponse(value);
            return;
        }
        var offset = 0;
        while (offset < value.byteLength) {
            let len = Math.min(value.byteLength - offset, BYTES_PER_WRITE);
            let chunk_contents = value.slice(offset, offset + len);
            console.log("write subarray", offset, chunk_contents);
            // Delay to ensure the last value was written to the device.
            await this.sleep(100);
            await rxCharacteristic.writeValueWithoutResponse(chunk_contents);
            offset += len;
        }
    } catch (e) {
        console.log("caught write error", e, e.stack);
    }
  }
}

async function connectToBLESerial() {
  serialService = await bleServer.getPrimaryService(bleNusServiceUUID);
  // TODO: create a terminal for each serial service
  txCharacteristic = await serialService.getCharacteristic(bleNusCharTXUUID);
  rxCharacteristic = await serialService.getCharacteristic(bleNusCharRXUUID);

  txCharacteristic.addEventListener('characteristicvaluechanged', onBLESerialReceive);
  await txCharacteristic.startNotifications();
}

async function switchToDevice(device) {
  bleDevice = device;
  bleDevice.addEventListener("gattserverdisconnected", onDisconnected);
  bleServer = bleDevice.gatt;
  console.log("connected", bleServer);

  const services = await bleServer.getPrimaryServices();
  console.log(services);

  console.log('Getting Transfer Service...');
  client = new FileTransferClient(bleDevice);
  debugLog("connected");
  connectToBLESerial();

  bond.disabled = false;
  connect.disabled = true;
  request.disabled = true;
}

async function onSerialConnected(e) {
  console.log(e, "connected!");
}

async function onSerialDisconnected(e) {
  console.log(e, "disconnected");
}

async function switchToSerial(device) {
  if (serialDevice) {
    await serialDevice.close();
  }
  serialDevice = device;
  device.addEventListener("connect", onSerialConnected);
  device.addEventListener("disconnect", onSerialDisconnected);
  console.log("switch to", device);
  await device.open({baudRate: 115200});
  console.log("opened");
  let reader;
  while (device.readable) {
    reader = device.readable.getReader();
    try {
      while (true) {
        const { value, done } = await reader.read();
        if (done) {
          // |reader| has been canceled.
          break;
        }
        terminal.io.print(decoder.decode(value));
      }
    } catch (error) {
      // Handle |error|...
      console.log("error", error);
    } finally {
      reader.releaseLock();
    }
  }

}

async function connectToBluetoothDevice(device) {
  const abortController = new AbortController();

  device.addEventListener('advertisementreceived', async (event) => {
    console.log('> Received advertisement from "' + device.name + '"...');
    // Stop watching advertisements to conserve battery life.
    abortController.abort();
    console.log('Connecting to GATT Server from "' + device.name + '"...');
    try {
      await device.gatt.connect()
      console.log('> Bluetooth device "' +  device.name + ' connected.');

      await switchToDevice(device);
    }
    catch(error) {
      console.log('Argh! ' + error);
    }
  }, { once: true });
  debugLog("connecting to " + device.name);
  try {
    console.log('Watching advertisements from "' + device.name + '"...');
    await device.watchAdvertisements({ signal: abortController.signal });
  }
  catch(error) {
    console.log('Argh! ' + error);
  }
}

var unchanged = 0;
async function onBond() {
  console.log("bond");
  await client.bond();
  var contents = await client.readFile("/code.py");
  editor.setState(EditorState.create({
    doc: contents,
    extensions: [
    basicSetup,
    python(),
    EditorView.updateListener.of(onTextChange)]
  }));
  unchanged = editor.state.doc.length;
  console.log("doc length", unchanged);
  console.log("bond done");
}

async function onDisconnected() {
  debugLog("disconnected");
  await bleServer.connect();
  debugLog("connected");
  connectToBLESerial();
}

async function onRequestBluetoothDeviceButtonClick() {
  try {
    console.log('Requesting any Bluetooth device...');
    debugLog("Requesting device. Cancel if empty and try existing");
    bleDevice = await navigator.bluetooth.requestDevice({
     filters: [{services: [0xfebb]},], // <- Prefer filters to save energy & show relevant devices.
     // acceptAllDevices: true,,
      optionalServices: [0xfebb, bleNusServiceUUID]
    });

    console.log('> Requested ' + bleDevice.name);
    await bleDevice.gatt.connect();
    switchToDevice(bleDevice);
  }
  catch(error) {
    console.log('Argh! ' + error);
    debugLog('No device selected. Try to connect to existing.');
  }
}

async function onRequestSerialDeviceButtonClick() {
  let devices = await navigator.serial.getPorts()
  if (devices.length == 1) {
    let device = devices[0];
    switchToSerial(device);
    return;
  }
  try {
    console.log('Requesting any serial device...');
    let device = await navigator.serial.requestPort();

    console.log('> Requested ');
    console.log(device);
    switchToSerial(device);
    return;
  }
  catch(error) {
    console.log('Argh! ');
  }
}

var editor;
var currentTimeout = null;
async function writeText() {
    console.log("sync starting at", unchanged, "to", editor.state.doc.length);
    if (!client) {
      console.log("no client");
      return;
    }
    let encoder = new TextEncoder();
    let doc = editor.state.doc;
    let same = doc.sliceString(0, unchanged);
    let offset = encoder.encode(same).byteLength
    let different = doc.sliceString(unchanged);
    let contents = encoder.encode(different);
    console.log(offset, different);
    let oldUnchanged = unchanged;
    unchanged = doc.length;
    try {
        console.log("write");
        await client.writeFile("/code.py", offset, contents);
    } catch (e) {
        console.log("write failed", e, e.stack);
        unchanged = Math.min(oldUnchanged, unchanged);
        if (currentTimeout != null) {
            clearTimeout(currentTimeout);
        }
        currentTimeout = setTimeout(writeText, 2000);
    }
}

async function onTextChange(update) {
  if (!update.docChanged) {
    return;
  }
  var hasGap = false;
  update.changes.desc.iterGaps(function(posA, posB, length) {
    // this are unchanged gaps.
    hasGap = true;
    if (posA != 0 && posB != 0) {
        return;
    } else if (posA == 0 && posB == 0) {
        unchanged = Math.min(length, unchanged);
    } else {
        unchanged = 0;
    }
  });
  // Everything has changed.
  if (!hasGap) {
    unchanged = 0;
  }

  if (currentTimeout != null) {
    clearTimeout(currentTimeout);
  }
  currentTimeout = setTimeout(writeText, 750);
}

if (navigator.bluetooth) {
  connect.addEventListener('click', function() {
      onConnectToBluetoothDevicesButtonClick();
  });
  request.addEventListener('click', function() {
      onRequestBluetoothDeviceButtonClick();
  });
  bond.addEventListener('click', function() {
      onBond();
  });

  bond.disabled = true;

} else {
  console.log("bluetooth not supported on this browser");
}

if (navigator.serial) {
  request_serial.addEventListener('click', function() {
    onRequestSerialDeviceButtonClick();
  });
} else {
  request_serial.disabled = true;
}

import {EditorState, EditorView, basicSetup} from "./_snowpack/pkg/@codemirror/basic-setup.js"
import {python} from "./_snowpack/pkg/@codemirror/lang-python.js"

editor = new EditorView({
  state: EditorState.create({
    doc: "Connect to load code.py",
    extensions: [basicSetup]
  }),
  parent: document.querySelector('#editor')
})

function setupHterm() {
  // hterm.defaultStorage = new lib.Storage.Local();
  // profileId is the name of the terminal profile to load, or "default" if
  // not specified.  If you're using one of the persistent storage
  // implementations then this will scope all preferences read/writes to this
  // name.
  const t = new hterm.Terminal();
  terminal = t;
  t.onTerminalReady = function() {
    // Create a new terminal IO object and give it the foreground.
    // (The default IO object just prints warning messages about unhandled
    // things to the the JS console.)
    const io = t.io.push();

    debugLog("connect to a device above");

    io.onVTKeystroke = async (str) => {
      serialTransmit(str);
    };

    io.sendString = async (str) => {
      serialTransmit(str);
    };

    io.onTerminalResize = (columns, rows) => {
      // React to size changes here.
      // Secure Shell pokes at NaCl, which eventually results in
      // some ioctls on the host.
      console.log("resize", columns, rows);
    };

    // You can call io.push() to foreground a fresh io context, which can
    // be uses to give control of the terminal to something else.  When that
    // thing is complete, should call io.pop() to restore control to the
    // previous io object.
  };
  t.decorate(document.querySelector('#terminal'));
  t.installKeyboard();
}

// This will be whatever normal entry/initialization point your project uses.
window.onload = async function() {
  await lib.init();
  setupHterm();
};

</script>

  </body>
</html>
